\NeedsTeXFormat{LaTeX2e}
\documentclass[runningheads]{llncs}
\usepackage{times}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{ifthen}
\usepackage{calc}
\sloppy

\begin{document}

\title{Why Itâ€™s Nice to be Quoted: Quasiquoting for Prolog}
\pagestyle{empty}

\author{Jan Wielemaker}
\institute{Web and Media group,
	   VU University Amsterdam, \\
	   De Boelelaan 1081a, \\
	   1081 HV Amsterdam,
	   The Netherlands, \\
	   \email{J.Wielemaker@vu.nl}}


\maketitle
\bgroup
\makeatletter
%\newcommand{\TBD}[1]{\textbf{#1}}

\newcommand{\jargon}[1]{{\em #1}}
\newcommand{\reffont}{\tt}
\newcommand{\predref}[2]{{\bf #1/#2}}
\newcommand{\dcgref}[2]{\mbox{\reffont #1//#2}}
\newenvironment{itemlist}
  {\itemize
   \renewcommand\makelabel[1]{%
     \hspace\labelwidth
     \llap{\@itemlabel}%
     \hspace\labelsep
     \makebox[\linewidth][l]{\it ##1}%
     \hspace{-\labelsep}}%
     }%
  {\enditemize}
\definecolor{codeboxcolor}{rgb}{0.4,0.4,0.4}
\DefineVerbatimEnvironment%
  {code}{Verbatim}
  {frame=single,
   framerule=0.2pt,
   rulecolor=\color{codeboxcolor},
  }
\newcommand{\const}[1]{{\tt #1}}
\renewcommand{\arg}[1]{\ifmmode\mbox{\em #1}\else{\it #1}\fi}
\newcommand{\secref}[1]{section~\ref{sec:#1}}
\newcommand{\figref}[1]{figure~\ref{fig:#1}}
\def\term{}
\renewcommand{\term}[2]{%
	\ifthenelse{\equal{\protect}{\protect#2}}{%
	    {\reffont #1}}{%
	    {\reffont #1}({\it #2})}}
\catcode`\^^A=8% downarrow are for subscripts
\catcode`\_=\active
\def_{\ifmmode\else\_\fi}
\newcommand{\bnfmeta}[1]{\ifmmode{\langle\mbox{\it #1}\rangle}\else$\langle\mbox{\it #1}\rangle$\fi}

\newcommand{\onlinebreak}{}
\def\@nodescription{false}
\newcommand{\nodescription}{\def\@nodescription{true}}
\newcommand{\defentry}[1]{\definition{#1}}
\renewcommand{\definition}[1]{%
	\onlinebreak%
	\ifthenelse{\equal{\@nodescription}{true}}{%
	    \def\@nodescription{false}%
	    \makebox[-\leftmargin]{\mbox{}}\makebox[\linewidth+\leftmargin-1ex][l]{\bf #1}\\}{%
	    \item[{\makebox[\linewidth+\leftmargin-1ex][l]{#1}}]}}
\def\predatt#1{\hfill{\it\footnotesize[#1]}}
\def\predicate{\@ifnextchar[{\@attpredicate}{\@predicate}}
\def\qpredicate{\@ifnextchar[{\@attqpredicate}{\@qpredicate}}
\def\@predicate#1#2#3{%
	\ifthenelse{\equal{#2}{0}}{%
	    \defentry{#1}}{%
	    \defentry{#1({\it #3})}}%
	\index{#1/#2}\ignorespaces}
\def\@attpredicate[#1]#2#3#4{%
	\ifthenelse{\equal{#3}{0}}{%
	    \defentry{#2\predatt{#1}}}{%
	    \defentry{#2({\it #4})\predatt{#1}}}%
	\index{#2/#3}\ignorespaces}
\def\@qpredicate#1#2#3#4{%
	\ifthenelse{\equal{#3}{0}}{%
	    \defentry{#1:#2}}{%
	    \defentry{#1:#2({\it #4})}}%
	\index{#1/#2}\ignorespaces}
\def\@attqpredicate[#1]#2#3#4#5{%
	\ifthenelse{\equal{#4}{0}}{%
	    \defentry{#2:#3\predatt{#1}}}{%
	    \defentry{#2:#3({\it #5})\predatt{#1}}}%
	\index{#2/#3}\ignorespaces}

\newcommand{\errorterm}[2]{\mbox{\tt%
	\ifthenelse{\equal{}{#2}}{%
	    error(#1, _)}{%
	    error(#1(#2), _)}}}
\newcommand{\termitem}[2]{%
	\ifthenelse{\equal{}{#2}}{%
	    \definition{#1}}{%
	    \definition{#1({\it #2})}}\ignorespaces}

\newcommand\satom{\begingroup \urlstyle{tt}\Url}
\newcommand{\chr}[1]{{\tt #1}}
\urldef{\Sbar}\satom{|}			% |
\urldef{\Spercent}\satom{%}		% %
\urldef{\Scut}\satom{!}			% !
\makeatother

\begin{abstract}
Prolog's support for dynamic programing, meta programming and text
processing using context free grammars make the language highly suitable
for defining \textit{domain specific languages} (DSL) as well as
analysing, refactoring or generating expressions states in other
(programming) languages. Well known DSLs are the DCG (Definite Clause
Grammar) notation and constraint languages such as CHR. These extensions
use Prolog operator declarations and the \mbox{\{\ldots\}} notation to
realise a good syntax. When external languages, such as HTML, SQL or
JavaScript enter the picture, operators no longer satisfy for embedding
snippets of these languages into a Prolog source file.  In addition,
Prolog has poor support for quoting long text fragments.

Haskell introduced \textit{quasi quotations} to resolve this problem.
In this paper we `ported' the Haskell mechanism for quasi quoting to
Prolog.  We show that this can be done cleanly and that quasi quoting
can solve the above mentioned problems.
\end{abstract}

%\tableofcontents

%================================================================
\section{Introduction}
\label{sec:intro}

Prolog is commonly used for tasks where it needs to manage snippets of
code written in the syntax of an external language such as HTML, SQL or
JavaScript. The syntax languages cannot be turned onto valid Prolog
syntax for various reasons \cite{WLPE/Wielemaker/2012}:

\begin{itemize}
    \item
Using operator syntax, both only prefix, infix and postfix
operators are insufficient.  For example, consider the JavaScript
case statement.
    \item
Basic lexical primitives are incompatible.   For example, consider textual
content in HTML documents.
    \item
The Prolog term that results from parsing an expression is
insufficient for recovering the intend in the target language.
For example, consider identifier names that start with an uppercase
letter, which will read as a Prolog variable.
\end{itemize}

In \cite{WLPE/Wielemaker/2012}, we claim that some simple language can
be covered well using these techniques, while it is possible to realise
acceptable representations e.g., XML based languages by using a Prolog
syntax that carries the (simple) datamodel of the language and others
(e.g. SQL) can be supported partially using semantic transformations. In
the above paper we propose a number of syntactic extensions to broaden
the range of languages that can be supported using one of the above
means.

In this paper, we propose a solution for complex external languages for
which none of the above is applicable. The solution is called quasi
quoting and borrowed from Haskell. A Haskell quasi quote consists of a
function symbol and quoted text. The function can manipulate the text
and massage it to fit further processing by Haskell. It is good practice
for the function to create an abstract syntax tree by parsing the text
according to the rules of the external language. As we will see in this
paper, more lightweight approaches can also be sufficient.

This paper is organised as follows. First, we revisit the problem
statement and indicate why current support in Prolog is insufficient to
solve this in an acceptable way. In \secref{quasiquote} we introduce the
notion of quasi quoting and how it fits into managing strings that
present datastructures in other languages. In \secref{plqq}, we
introduce the concrete solution proposed for SWI-Prolog.  This is
followed by examples and a conclusion.


\section{The need to integrate external languages in Prolog}

We will explain this need by an example from SWI-Prolog's web page
generating facilities \cite{TPLP06}. Web pages are by no means the only
place where these problems arise \cite{DBLP:conf/haskell/2007}, but the
domain is quite familar to many programmers and is of particular
interest to us because generating web pages is an important application
area for SWI-Prolog. A modern web page typically consists of HTML that
creates the initial DOM structure, CSS that provides styling and
JavaScript for creating interactive components. Our solution for
generating HTML is similar to PiLLoW \cite{PiLLoW} and based on
representing the HTML DOM structure as a nested Prolog term.  The
SWI-Prolog HTML page generation library has matured and provides
good solutions for

\begin{itemize}
    \item Generating the page structure.
    \item Definition and reuse of DCGs that generate page fragments.
    \item Create references (URLs) to other pages on the server.
    \item Modular inclusion of resources, such as style and
          JavaScript files including dependency tracking and
	  automatic ordering by computing a partial order based
	  on the dependencies.
\end{itemize}

Pages generated with this infrastructure are guaranteed to be
syntactically correct, regardless of the data from which the
page is created.  This built-in protection against injection
attacks is considered a key asset of the server infrastructure.

In ealier publications \cite{WLPE/Wielemaker/2012,TPLP06} we already
identified two missing pieces: (1) longer (HTML) text fragments and (2)
JavaScript fragments. The first problem can be solved using
PWP\footnote{Prolog Well-formed Pages,
\url{http://www.swi-prolog.org/pldoc/package/sgml.html}}, which is the
opposite of the above described Prolog based page generator. The page is
described in XML and reserved XML elements and tags trigger the
generation of dynamic page components based on the evaluation of Prolog
goals. Like the Prolog page generator, PWP protects against injection
attacks because it considers solutions from Prolog as data that is
included into the XML DOM prior to generating the page. PWP simplifies
the specification of pages with large amounts of text, but the rule
format is less natural and it lacks the modularity of the Prolog based
generator.

We have been struggling with JavaScript using various approaches.
Currently, there is a large number of JavaScript frameworks that provide
`widgets' for use on web pages. Popular examples are YUI and jQuery,
optionally combined with Bootstrap. Including these widgets typically
demands creating some a DOM structure that carries an \verb$id$
attribute and represents the data (e.g., a menu may be represented as a
\verb$ul$ list or an advanced text editor can be represented as a
\verb$textarea$). This DOM element is transformed into the target web
element by calling a JavaScript initialization function that modifies
the DOM of the target element and installs \textit{event handlers} that
provide the dynamic behavior of the element. The initialization function
typically requests a \textit{configuration} object (a JavaScript object
literal, \mbox{\{name:value, \ldots\}}), where some of the values are
\textit{callback functions}, represented as JavaScript Lambda functions.

The HTML framework is well equipped to create the initial DOM and pull
in the JavaScript and CSS resources using its dependency framework. The
initialization call is easy enough to abstract, except when the
configuration object contains Lambda functions. These are often required
to massage the data into the desired vizualization and support AJAX
based operations, such as computing autocompletion candidates. It is
quite common for such objects to require dozens of lines of JavaScript.
Representing JavaScript Lambda functions requires support for the the
complete complexity of the language. One way to do this is to represent
the JavaScript fragment as a list of literals, mixed with DCG rules that
insert content generated from Prolog, such as URLs or JavaScript literal
objects. This leads to code as below, which we consider hard to type,
hard to read and because it is so hard to read, often subject to syntax
errors. Finally, the code below is subject to injection attacks, unless
we hand the variables \arg{URL} and \arg{Id} to a grammar that generates
valid JavaScript string content.

\begin{code}
	[ '$.ajax({ url: "',URL,'",\n',
	  '	    data: { id: "',Id,'",\n',
          '               }\n',
          '       });\n'
	]
\end{code}

We tried several designs to improve on the above, none of which we
considered satisfactory. Below are the main directions that we tried.

\begin{itemize}
    \item Abstract away.  This implies using the HTML page generation
          facilities to generate e.g., make a JavaScript call,
	  initialize a variable from Prolog data, etc.  To remain
	  managable, a fairly high level of abstraction is needed
	  that is geared towards the JavaScript framework.  This is
	  problematic because it makes it hard for the programmer to
	  relate the JavaScript examples from the framework
	  documentation to the Prolog code.  Although it is possible
	  to abstract some of the Lambda functions, the variation is
	  too big to deal with all of them.
    \item Put the JavaScript in a separate file.  This creates many
          short files that typically only support a specific generated
	  HTML page because the details of the required JavaScript, such
	  as locations on the server that must be addressed vary from
	  page to page.  Because there is no formal relation between
	  the two pages, it is hard to relate them and keep them in
	  sync.
    \item Create application specific JavaScript resources that can be
	  configured without the need for Lambda functions in the their
	  configuration object. The problem here is that you create your
	  own refinement of the external widget library that requires
	  understanding and documentation, while the externally provided
	  libraries are already quite high level.  In other words, the
	  newly created layer adds mostly confusion.
\end{itemize}

We have come to the conclusion that (1) we need a mechanism that allows
us to include JavaScript into the Prolog page generation source code
because putting the relatively short fragments in a separate file while
the Prolog and JavaScript file are highly dependent is not managable,
(2) The representation of JavaScript in the Prolog source must be easy
to type and understand and (3) the generated JavaScript should be
saveguarded against injection attacks without the need for user
involvement and (4) syntactic validation of the generated fragments are
likely to improve productivity.


\section{Using Prolog syntax}
\label{sec:syntaxext}

First, we investigated to what extend the extensions proposed in
\cite{WLPE/Wielemaker/2012} would help. We realised support for the
empty argument lists (e.g., \verb$name()$), array notation and function
bodies using \mbox{\{\ldots\}}. These were resolved after a proposal by
Jose Morales, which extends the notion of operators to lists and
curly-bracket blocks. In addition to our hope of improving JavaScript
support, list subscription and curly-bracket attribute lists are in use
with B-Prolog and ECLiPSe for realizing enhanced DSL support.

We have realised a prototype that can express a fair deal of the
JavaScript syntax with the following problems:

\begin{itemize}
    \item It requires ! and . to be defined as operators.  These
          operators are known to cause ambiguity issues.
    \item Quoting of identifiers may be needed (e.g., \verb$'String'(...)$)
    \item A special symbol is needed to distinguish identifiers from strings.
          ("string" cannot be used because it is a list of integers).
    \item Restictions are needed with regard to spaces.  No space is
          allowed after function symbols and keywords such as
	  \const{while}.  In some places additional spaces are required
	  to prevent Prolog from reading two JavaScript tokens as a
	  single Prolog token.
    \item Some symbols clash with Prolog.  Consider \chr{|} or \chr{%}.
    \item Some terms cannot be classified properly.  For example,
          \verb$++a$ is different from \verb$a++$, but both result in
	  the Prolog term ++(a).
\end{itemize}

We believe that the result would have been more usable than using Prolog
quoted atoms for short (1-10 lines) JavaScript snippets, that include
simple Lambda functions such as making AJAX callbacks. Our main point of
doubt is that it is hard to convey the restrictions to casual Prolog
users, which makes it likely to get surprised by output that differs
from the expectations and can only be understood by deep knowledge of
Prolog's syntax and underlying term representation.

\section{The three problems}
\label{sec:thebigthree}

If we cannot include JavaScript using (operator extended) Prolog syntax,
the other option is to use (quoted) text. For this, we need to solve
three orthogonal problems:

\begin{enumerate}
    \item Allow for long quoted text.  Current (ISO) Prolog only provides
    single and double quoted text, which follow the same rules. In
    particular

    \begin{itemize}
        \item Quoted text cannot span more than one line, unless the
	      newline is escaped with a backslash.
        \item The backslash and quote must be escaped.
	\item If good layout of the output is desirable, there is
	      no way to indent continuation lines in the Prolog source
	      such that the indentation does not show up in the output.
    \end{itemize}

    These restrictions are unsuitable for embedding many programming
    languages.

    \item Relate Prolog variables (data) to references in the quoted
    material.

    \item Establish a safe way to embed data into the template string.
\end{enumerate}

These problems are independent.  We illustrate this with a small HTML
example that presents a page with the current time.  We use an HTML
skeleton to make the comparison fair.  In pure Prolog, this could be
achieved using the following code snippet:

\begin{code}
	...,
	get_time(Now),
	format_time(atom(Date), '%+', Now),
	print_html([date=Date],
		   '<h1>My digital clock</h1>\n\
		    <p>It is now {{date}}</p>').
\end{code}

The task of print_html/2 is to relate the template variable \const{date}
to the Prolog variable \arg{Date} (third item above), determine the
lexical context of \mbox{\{\{date\}\}} to know the proper encoding that
needs to be done, realise this encoding on the Prolog atom and create
the proper output string. This is the second item on the list above.
Ideally, we would like an error if the HTML fragment is malformed to
begin with.

In pure ISO Prolog, all work must be done at runtime. Many Prolog
systems provide goal_expansion/2 or similar, which allows for doing the
analysis of the template at compile time. What remains on our wishlist
is to (1) get rid of \verb$[date=Date]$ and (2) get rid of complicated
escape sequences for languages that frequently use quotes or
backslashes. We propose to solve both issues using quasi quotations for
Prolog.


\section{Quasi Quotations}

Quasi quotations find their origin in
linguistics\footnote{\url{http://en.wikipedia.org/wiki/Quasi-quotation}}
and introduces \textit{variables} into textual expressions. They are
commonly used in \textit{scripting} languages. For example:

\begin{code}
a=world; echo "Hello $a"	// Unix shell
$a = "world"; print "Hello $a"; // Perl
\end{code}

This approach feels natural to the (novice) programmer. Unfortunately it
does not work for Prolog because nothing in Prolog the normal Prolog
compilation process provides access to the names of variables. In
addition, plain text insertion is a direct invitation to
\textit{injection} attacks. As described in \secref{thebigthree}, the
template replacement code must be aware of the syntax to perform a safe,
i.e., properly escaped, insertion of the variable.

Haskell quasi quotes resolve the injection problem (which is described
as a \emph{typing} problem in \cite{DBLP:conf/haskell/2007}) by
associating a \emph{function} directly with the quoted data. The
function typically parses the quoted material into an abstract syntax
tree that can represent the target language.


\section{Quasi Quotations in Prolog}

We can solve our three problems by adding a syntactic construct that (1)
provides long quoted strings, (2) associates the quoted material to a
predicate that can act on it according to the requirements of processing
the external language and (3) provides access the the clause's variable
dictionary.

A solution for (1) that fits the spirit of Prolog is the triple quote
(\verb$"""..."""$) using by e.g., Python and Turtle. This options is not
possible because \verb$""$ is the string escape for \verb$"$ and
therefore \verb$"""$ is the legal start of a Prolog string. The Ruby
language has a particularly large set of string escape
languages\footnote{\url{http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals}},
none of which seems promising in the context of Prolog. The fact that
Prolog symbol characters glue together and that sequences of symbol
characters, singletons (e.g., !, and \chr{|}) can be used as operators
limit the options. New syntax for Prolog should generally consider using
two consequtive tokens that cannot be operators. With our extended
operators (\secref{syntaxext}), that only leaves variables, numbers and
double quoted strings. One option could be a triple quoted string
prefixed or postfixed with a variable, as shown below.  The downsite
of this is that this may well be legal syntax with a different meaning
if the \verb$L$ is forgotten.

\begin{code}
	L"""..."""
\end{code}

Instead of searching for long quoted syntax, we can also look at
quotation marks that embed types. Here, we see the Haskell example of
\verb$[type|quoted]$ and the XML example \verb$<![CDATA[quoted]]>$. The
XML example is particularly interesting because the \chr{!} is a poor
choice for an
operator\footnote{\url{http://comments.gmane.org/gmane.comp.lang.swi-prolog.general/5609}},
while the remainder is not a valid Prolog list.  Following this, we
propose the following syntax for Prolog quasi quotations, where
\arg{Type} is an arbitrary callable Prolog term:

\begin{code}
	<![Type[Quoted]]>
\end{code}

Occurrences of \verb$]]>$ inside the quoted material must be resolved
using alternatives or escape mechanisms of the quoted target language.
For example the legal JavaScript expressions \verb$a[a[1]]>2$ can be
quoted by introducing additional white space.\footnote{Example by
Richard O'Keefe} If additional measures are needed, we propose
considering alternative start- and end sequences for further
considerations. For example, \verb$<!{Type{Quoted}}>$ or
\verb$<!MAGIC[Type[Quoted]]MAGIC>$, where \arg{MAGIC} can be a
user-defined sequence of uppercase letters.

Orthogonal to the syntax is the mapping of this construct to a Prolog
term.  This mapping is defined by the \arg{Type}.  At the same time,
quasi quotation merges (Prolog) variables from the environment into
the quoted material.  Therefore, we define that:

\begin{itemize}
    \item The predicate read/1 collects the \arg{Type} term and the
          quoted text.
    \item After all normal processing is finished, read/1 calls the
	  term below.

\begin{code}
call(+TypeName, +Content, +TypeArgs, +VarDict, -Result)
\end{code}

	  Above, \arg{TypeName} is the functor of the \arg{Type} term
	  and \arg{TypeArgs} is the list of arguments, i.e.,
	  \verb$Type =.. [TypeName|TypeArgs]$.  In \secref{examples},
	  we will see why it is useful to split the functor from the
	  arguments.  \arg{Content} is an opaque handle to the quoted
	  material as we will see later.  \arg{VarDict} is
	  \mbox{\arg{Name} = \arg{Var}} list conforming to read_term/3
	  and write_term/3.  \arg{Result} is determined by the call to
	  the deterministic predicate \arg{TypeName}/4.
\end{itemize}

We provide two support predicates for \arg{TypeName}/4 to process the
result.  Note that there are no limits on how the called predicate
combines the quoted text with the type arguments and variable dictionary
to construct the final term.

\begin{description}
    \predicate{phrase_from_quasi_quotation}{2}{:Grammar, +Content}
Calls the grammar \arg{Grammar} on the list formed by \arg{Content}.
This predicate uses the \jargon{pure input} library described in
\cite{CYCLOPS/Wielemaker/2008} to parse the content.  Syntax errors
may be raised using the non-terminal syntax_error//1, which produces
a precise syntax location that consists of the file, line number,
line position and character count.

    \predicate{with_quasi_quotation_input}{3}{+Content, -Stream, :Goal}
Calls \arg{Goal} on the Prolog stream \arg{Stream}.  The stream position
information reflects the location in the source file, except for the
byte count.
\end{description}


\section{Examples of using quasi quotes in Prolog}
\label{sec:examples}

In this section we provide some examples to illustrate the power of
these facilities. The first, complete, example illustrates safe
embedding of long HTML texts in a Prolog web page.  The code of
the quasi quoter is given in \figref{htmlqq}.  First, we give a
fully working webserver based on this quasi quoter:

\begin{code}
:- use_module(library(http/thread_httpd)).
:- use_module(library(http/http_dispatch)).
:- use_module(library(http/html_write)).

server(Port) :- http_server(http_dispatch, [port(Port)]).

:- http_handler(/, index, []).

index(_Request) :-
	get_time(Now),
	format_time(atom(Date), '%+', Now),
	reply_html_page(
	    title('My digital clock'),
	    <![html(Date)
	       [<h1>My digital clock</h1>

		<p>It is now <span class="time">Date</span>
	       ]]>).
\end{code}






\begin{figure}
\begin{code}
:- module(html_quasi_quotations, [ html/4 ]).
:- use_module(library(sgml)).
:- use_module(library(apply)).
:- use_module(library(lists)).
:- use_module(library(quasi_quotations)).

:- quasi_quotation_syntax(html).

html(Content, Vars, Dict, DOM) :-
	include(qq_var(Vars), Dict, QQDict),
	with_quasi_quotation_input(
	    Content, In,
	    load_html(In, DOM0,
		      [ max_errors(0)
		      ])),
	xml_content(QQDict, DOM0, DOM).

qq_var(Vars, _=Var) :- member(V, Vars), V == Var, !.

xml_content(Dict, [Name], [Var]) :-
	atom(Name),
	memberchk(Name=Var, Dict), !.
xml_content(Dict, Content0, Content) :-
	maplist(xml_content_element(Dict), Content0, Content).

xml_content_element(Dict,
		    element(Tag, Attrs0, Content0),
		    element(Tag, Attrs, Content)) :- !,
	maplist(xml_attribute(Dict), Attrs0, Attrs),
	xml_content(Dict, Content0, Content).
xml_content_element(_, Element, Element).

xml_attribute(Dict, Attr=Name, Attr=Var) :-
	memberchk(Name=Var, Dict), !.
xml_attribute(_, Attr, Attr).
\end{code}
    \caption{Source for the HTML quasi quoter}
    \label{fig:htmlqq}
\end{figure}




















%================================================================
\subsection*{Acknowledgements}


\bibliographystyle{plain}
\bibliography{quasiquoting}

\egroup

\end{document}


